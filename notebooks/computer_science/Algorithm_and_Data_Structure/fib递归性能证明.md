# 朴素递归 Fibonacci 的时间复杂度证明：T(n)=Θ(φ^n)

## 1. 朴素递归算法（定义）
令 fib(n) 为：

- fib(0)=0, fib(1)=1
- fib(n)=fib(n-1)+fib(n-2)  (n>=2)

朴素递归实现：

fib(n):
  if n<=1: return n
  return fib(n-1)+fib(n-2)

令 T(n) 为运行时间（或递归调用次数，二者只差常数倍）。

则存在常数 c>0，使得对 n>=2：
T(n) = T(n-1) + T(n-2) + c

我们证明：T(n)=Θ(φ^n)。

---

## 2. 下界：T(n)=Ω(φ^n)

由递推式对 n>=2：
T(n) = T(n-1)+T(n-2)+c ≥ T(n-1)+T(n-2)

定义序列 S(n)=T(n)（仅用于下界），则：
S(n) ≥ S(n-1)+S(n-2)

注意 Fibonacci 数列 F(n) 满足：
F(n)=F(n-1)+F(n-2), 且 F(0)=0, F(1)=1

选择一个常数 k>0（例如 k=1，或者根据初值取更小的常数），
用归纳法可证明对所有 n>=0：
T(n) ≥ k·F(n)

证明思路（归纳）：
- 基础：对 n=0,1 取合适 k 使成立
- 归纳：若 T(n-1)≥kF(n-1), T(n-2)≥kF(n-2)
  则 T(n)≥T(n-1)+T(n-2) ≥ k(F(n-1)+F(n-2))=kF(n)

因此：
T(n)=Ω(F(n))

而已知 Fibonacci 的闭式增长：
F(n) = Θ(φ^n)

所以：
T(n)=Ω(φ^n)

---

## 3. 上界：T(n)=O(φ^n)

从递推式出发，对 n>=2：
T(n) = T(n-1)+T(n-2)+c

我们要证明存在常数 A>0，使得对所有 n：
T(n) ≤ A·φ^n

做归纳证明。

### 3.1 选择 A
先取 A 足够大，使得基础情况成立：
T(0) ≤ A·φ^0 = A
T(1) ≤ A·φ^1 = Aφ

这总能做到（取 A≥max(T(0), T(1)/φ)）。

同时我们还需要一个关键不等式来“吸收”常数 c：
希望最终得到：
A + c ≤ A·φ   （等价于 c ≤ A(φ-1)）
所以只要再令：
A ≥ c/(φ-1)
即可。

综上：取 A 足够大，同时满足基础条件与 A ≥ c/(φ-1)。

### 3.2 归纳步骤
假设对 n-1 与 n-2 成立：
T(n-1) ≤ A·φ^(n-1)
T(n-2) ≤ A·φ^(n-2)

则：
T(n) = T(n-1)+T(n-2)+c
    ≤ A·φ^(n-1) + A·φ^(n-2) + c
    = A·φ^(n-2)(φ+1) + c

利用黄金比例性质：φ^2 = φ + 1
所以：
A·φ^(n-2)(φ+1) = A·φ^(n-2)·φ^2 = A·φ^n

于是：
T(n) ≤ A·φ^n + c

现在要把 +c 吞掉。
因为 φ^n ≥ φ（对 n>=1），所以：
c ≤ c·φ^(n-1)

更直接地，用我们对 A 的选择：
c ≤ A(φ-1)

两边乘以 φ^(n-1)（n>=1）得：
c·φ^(n-1) ≤ A(φ-1)·φ^(n-1)

注意 (φ-1)·φ^(n-1) = φ^n - φ^(n-1)
因此：
A·φ^n + c ≤ A·φ^n + A(φ^n - φ^(n-1)) = A·φ^(n+1) - A·φ^(n-1)

这说明在 n 增大时常数项不会改变指数阶。

更简洁的处理方式是：因为 A 已选得足够大，
对 n>=2 有：
A·φ^n + c ≤ A·φ^n + A(φ^n)(φ-1)/φ = A·φ^n(1 + (φ-1)/φ) = A·φ^(n+1)/φ
仍为 O(φ^n)。

因此归纳成立，得到：
T(n)=O(φ^n)

---

## 4. 合并上下界

由 2 得：
T(n)=Ω(φ^n)

由 3 得：
T(n)=O(φ^n)

所以：
T(n)=Θ(φ^n)

---

## 5. 补充：空间复杂度

递归深度为 n，因此空间（调用栈）为：
Space(n)=Θ(n)
