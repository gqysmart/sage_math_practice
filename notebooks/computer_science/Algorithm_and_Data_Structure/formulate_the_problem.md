# Formulate the Problem ≈ Entering the Computational Model  
## —— 从 KT（Kleinberg–Tardos）看“问题建模 × 计算模型 × 算法设计”

---

## 1. 问题背景与核心困惑

在阅读 KT（Kleinberg–Tardos）《Algorithm Design》时，尤其是在 **Stable Matching** 一章中，会出现一种强烈的直觉冲突：

> 刚刚 *formulate the problem*，  
> 为什么马上就开始 *designing the algorithm*？  
> 中间是不是“少了一步数学建模”？

进一步的问题是：

- formulating a problem 是不是已经在做计算模型？
- 是否可以先不写抽象数学模型，而通过算法过程来理解问题？
- 这种做法是不是 KT 特有的方法论？

---

## 2. 结论先行（精确表述）

> **在 KT 所讨论的结构性离散问题中，  
当问题被 formulate 清楚时，  
计算模型实际上已经被隐式确定了。**

换句话说：

> **formulate the problem  
≠ 仅仅是语言描述  
≈ 把现实问题翻译进一个“离散计算世界”**

算法并不是在“模型之后”，  
而是 **对这个计算世界的一种探索与证明方式**。

---

## 3. 什么叫“formulate 已经是计算模型”？

### 3.1 对象已经是计算对象

以 Stable Matching 为例：

| 现实概念 | Formulate 后 |
|--------|--------------|
| 男人 / 女人 | 离散节点 |
| 偏好 | 有序列表 |
| 婚配 | 一对一映射 |
| 稳定性 | 逻辑谓词（blocking pair 是否存在） |

这些对象具有共同特征：

- 有限
- 离散
- 可枚举
- 可比较

👉 **不再需要“连续 → 离散”的转换**

---

### 3.2 合法性由逻辑谓词定义，而非方程

Stable Matching 中的核心约束：

- 是否存在 blocking pair？
- 是否一对一？
- 是否违反偏好顺序？

这些判断：

- 是 True / False
- 不涉及实数
- 不涉及极限、导数、误差

👉 这是典型的 **计算模型（decision / search model）**

---

### 3.3 输入规模天然定义了复杂度语义

一旦 formulate：

- 输入规模 n 已经明确
- 偏好列表长度 = n
- 状态空间是有限的

因此：

- 时间复杂度
- 空间复杂度
- 终止性讨论

**在 formulate 时就已经具备语义基础**

---

## 4. 为什么 KT 可以“直接进入算法设计”？

### 4.1 关键原因：构造性问题 + 构造性证明

Stable Matching 属于一类特殊问题：

> **存在性证明可以通过构造一个过程来完成**

KT 明确写道（意译）：

> “我们通过展示存在性的方式，同时给出一个高效算法。”

也就是说：

- **算法 = 证明**
- **过程 = 逻辑推理**

这在数学中称为：

> **Constructive Proof（构造性证明）**

---

### 4.2 KT 实际使用的方法论

KT 在这里采用的不是：
- DP
- Greedy 模板
- 数学优化

而是：

> **Process-based Algorithm Design  
（基于过程的算法设计）**

核心思想是：

- 构造一个“受控的演化过程”
- 定义不变式
- 证明过程会终止
- 证明终点必然满足性质

---

## 5. 抽象数学模型真的“被放在后面了吗”？

### 5.1 表面现象

看起来是：

> formulate → algorithm

### 5.2 实际情况

真实顺序是：

1. **抽象已经完成**（但写在定义里，而不是公式里）
2. 数学对象 = 集合 / 顺序 / 映射 / 谓词
3. 算法过程 = 对这些对象的系统操作
4. 证明 = 对过程不变式的分析

👉 **数学模型没有消失，而是被“内化”了**

---

## 6. 算法作为“认识工具”的方法论

在 KT 的这些章节中，算法不只是“解题工具”，而是：

> **一种用来观察、验证、理解问题结构的手段**

可以把 Gale–Shapley 看成：

- 一个思想实验
- 一个社会过程的抽象
- 一个离散动力系统

KT 的工作是证明：

- 这个系统不会乱跑
- 它一定会收敛
- 收敛点就是稳定解

---

## 7. 这种方法论的适用边界（非常重要）

### 7.1 适用的情况（KT 型问题）

满足以下条件：

1. 问题是有限离散的
2. 解是组合结构（匹配 / 路径 / 割）
3. 约束是逻辑或结构性的
4. 存在“自然的演化过程”直觉

典型例子：
- Stable Matching
- Network Flow
- Min-Cut
- Bipartite Matching

---

### 7.2 不适用的情况

以下问题仍然**必须先显式数学建模**：

- 连续优化
- 数值分析
- 统计估计
- 深度学习训练

这些问题中：

- 目标函数是核心
- 误差模型不可省略
- 算法只是近似手段

---

## 8. 一个可复用的判断公式

以后遇到一个新问题，可以用这条判断：

> 如果  
> - 问题是离散的  
> - 约束是逻辑性的  
> - 解是结构而非数值  
> - 存在自然过程直觉  
>
> 那么  
> **formulate 时，计算模型几乎已经被锁定**

---

## 9. 总结（一句话版）

> **在 KT 的结构性离散问题中，  
formulate the problem 本身就等于进入计算模型；  
算法不是模型的附属，而是揭示模型结构的一种方式。**

---

## 10. 延伸理解（给自己的提醒）

- 不要误解为“算法代替模型”
- 正确理解是：
  > **模型在定义中，算法在过程里，证明在不变式中**

这是一种：
> **从“写模型”到“设计会变正确的系统”的思维转变**