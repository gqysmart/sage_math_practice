# Binary Search Mental Model v1.0

## 0. 一句话本质

二分查找不是“查找算法”，而是：

> 在单调解空间中，通过维护不变量，不断缩小解空间，直到定位解。

核心不是 `mid`，而是：

search space + invariant + shrink rule


---

# 1. 二分的三要素

## 1.1 解空间（Search Space）

可以是：

- index 空间：`[0, n-1]`
- 数值空间：`[1, 10^9]`
- 函数定义域
- 单调 predicate 空间

本质：

解存在于这个空间里


---

## 1.2 不变量（Invariant）

每一步必须保证：

解始终在当前区间内


例：

| 问题 | 不变量 |
|---|---|
| 查找 target | target ∈ [left,right] |
| 找最小值 | min ∈ 区间 |
| lower_bound | 第一个 ≥ target 的位置在区间 |
| 找 pivot | pivot 在区间 |
| 找峰值 | peak 在区间 |

不变量才是二分的“灵魂”。

---

## 1.3 收缩规则（Shrink Rule）

每次排除一半不可能区域：

排除后，不变量仍成立


---

# 2. 二分的两大范式（最重要）

所有二分只分两类：

---

## 2.1 查找“具体值”

目标：

找 target


特点：

- mid 是 candidate
- mid 必须被检查
- 可以排除 mid

模板：

```python
left, right = 0, n-1

while left <= right:
    mid = (left + right)//2
    
    if nums[mid] == target:
        return mid
    elif target < nums[mid]:
        right = mid - 1
    else:
        left = mid + 1
循环：

<=
更新：

mid ± 1
2.2 查找“边界”
目标：

最小值

pivot

lower_bound

first true

last false

特点：

mid 可能就是答案

mid 不能被排除

区间收缩为一个点

模板：

left, right = 0, n-1

while left < right:
    mid = (left + right)//2
    
    if condition(mid):
        right = mid
    else:
        left = mid + 1
循环：

<
更新：

right = mid
left = mid + 1
最终：

left == right
3. 判断使用哪个模板
问自己一件事：

mid 能不能被排除？
判断	模板
mid 一定不是答案	查找值（<=）
mid 可能是答案	找边界（<）
4. 不变量驱动思维
二分的真正写法顺序：

Step 1：定义解空间
[left,right]
Step 2：定义不变量
解始终在区间中
Step 3：写 mid 判断
判断哪一半不可能有解
Step 4：收缩区间
保证不变量仍成立
5. 常见二分类型
5.1 查找元素
target
用：

<=
5.2 lower_bound
第一个 ≥ target
用：

<
right = mid
5.3 upper_bound
第一个 > target
5.4 rotated array
pivot / min
5.5 peak element
局部最大
5.6 answer space binary search
解空间是：

数值
例：

最小可行速度

最大可行容量

sqrt

木材切割

6. 最核心公式
二分 =

维护不变量
+
解空间单调
+
每步排除一半
7. 二分的统一抽象
给定单调 predicate f(x)

False False False True True True

找：

- 第一个 True
- 最后一个 False
这就是所有二分的本体。

8. 常见错误
8.1 mid 写错
❌

mid = (right-left)//2
✔

mid = left + (right-left)//2
8.2 区间模型混用
[left,right] vs [left,right)
8.3 死循环
left=mid
right=mid
9. 心智模型（终极版）
二分不是：

在数组中找数
而是：

在单调结构的解空间中寻找边界
10. 一句话总结
查值 → <=
找边界 → <
11. 练习路线
必须按顺序：

binary search basic

lower_bound / upper_bound

rotated search

find min in rotated

peak element

answer-space binary search

monotonic predicate problems

12. 最终理解（算法层）
所有二分问题本质都是：

search on ordered structure
而 ordered 可以是：

index

value

time

capacity

probability

function domain

geometry