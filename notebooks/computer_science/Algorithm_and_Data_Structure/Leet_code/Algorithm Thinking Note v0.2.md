Algorithm Thinking Note v0.2
统一视角：算法 = 在状态空间中的受约束搜索 / 推理

任何计算问题都可以抽象为：

状态空间 S

目标集合 G（解空间）

转移规则 T

代价函数 C（是否最优）

不变量 I（必须保持成立的性质）

不同算法类型的差异，本质是：

用什么机制缩小状态空间并找到解

一、三大核心问题类型（统一模型）
1️⃣ 搜索驱动类（Graph / State traversal）

本质：在状态空间中“走”

目标：找到可行解 / 最优解

方法：控制扩展顺序

典型策略：

DFS

BFS

贪心

A*

核心思想：

状态空间存在
→ 我不知道解在哪
→ 需要“试探式遍历”
→ 用策略控制遍历顺序


关键不变量：

BFS：层级最短路径不变量

DFS：访问标记不变量

A*：f = g + h 单调性

贪心：局部最优假设

典型问题：

最短路径

图遍历

组合枚举

backtracking

2️⃣ 递推驱动类（DP / 状态记忆）

本质：不再“走路径”，而是对状态做“值传播”

关键特征：

子问题之间存在关联

状态可复用

存在递推不变量

DP 不是数据结构，而是：

基于不变量的计算方法 + 依赖数据结构缓存状态

典型结构：

dp[state] = 子问题最优解


依赖：

table / array / map

关键思想：

最优子结构

重叠子问题

状态压缩

前缀不变量

典型问题：

LIS

背包

最长子序列

编辑距离

股票买卖

⭐ DP 的本质补充（核心升级）

DP 折叠的是路径空间，保留的是状态空间

解释：

搜索：

按“路径”展开

同一个状态会在不同路径下重复出现

start
 ├─ a
 │   ├─ c
 │   └─ d
 └─ b
     ├─ c
     └─ d

DP：

按“状态”计算

同一状态只计算一次

dp[c] = ...
dp[d] = ...


于是：

搜索树（tree）
↓ 折叠路径
状态图（DAG）


本质变化：

维度	搜索	DP
推理单位	路径	状态
重复计算	多	无
结构	tree	DAG
核心操作	扩展路径	传播状态值
DP 的真正意义

DP 不是：

更快的搜索

而是：

把“按路径搜索”改成“按状态计算”

即：

Path-based reasoning
↓
State-based reasoning

更高阶表述（计算图）

DP =

Memoized Search
+
State Equivalence Merge
+
Computation Graph Compression


翻译：

记忆化搜索

状态等价合并

计算图压缩

折叠的数学含义

DP 本质是：

把“所有到达同一状态的路径”视为等价类

于是：

搜索树 → DAG


也就是：

路径空间被折叠
状态空间被保留

DP 与搜索的深层关系

实际上：

DFS = 显式搜索
DP = 折叠后的搜索


DP 是：

在状态图上做“值传播”的搜索

而不是：

在路径树上做“路径扩展”的搜索

DP 与 Bellman 统一公式

所有 DP / 最短路径 / RL 都符合：

value(state)
= best over transitions


这是：

动态规划

强化学习

控制理论

最短路径

的共同核心。

3️⃣ 数学推理类（Proof-driven）

本质：不是搜索，而是“推导”

驱动力：

定义

性质

定理

逻辑链

正确性来源：

严格证明

结构性质

典型：

数论

组合公式

概率期望

线性代数

凸优化

二、统一模型总结
问题 = 状态空间 + 约束 + 目标


三种解决路径：

类型	驱动力	行为
搜索型	策略	在空间里走
DP型	不变量	在状态间递推
数学型	定理	直接推导
三、算法识别卡片（面试/做题即时判断）
🎯 看到这些信号 → 搜索

关键词：

路径

最短步数

遍历

可达

组合

所有方案

🎯 看到这些信号 → DP

关键词：

子序列

连续

最优

方案数

第 i 个状态依赖前面

流程：

定义状态
↓
写递推式
↓
确定边界
↓
填表

🎯 看到这些信号 → 数学

关键词：

任意

存在

恒成立

证明

期望

收敛

四、顶层统一认知（重要）

所有算法本质都是：

搜索 + 不变量


区别：

类型	搜索显式？	不变量显式？
DFS/BFS	强	弱
DP	弱	强
数学	无	极强
五、最终一句话（核心哲学）
算法世界只有三种力量：

1. 我试着走（搜索）
2. 我一步步推（DP）
3. 我直接证明（数学）


而 DP 的位置是：

把“走路径”折叠成“算状态”

这句话非常关键，是算法理解的分水岭。

是否继续升级 v0.3

下一层将进入真正“算法设计者”视角：

什么条件下：
搜索可以折叠为 DP？


这涉及：

最优子结构

无后效性

状态可复用性

这是：

面试高频

研究级算法建模

RL / 控制系统基础