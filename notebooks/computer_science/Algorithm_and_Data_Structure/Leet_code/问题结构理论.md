好，我们直接进入这一层：

Problem Structure Theory v0.1
为什么有的问题用搜索，有的能变 DP，有的直接是数学？

这是算法设计真正的分水岭。

不是“你会不会写代码”，
而是：

你能不能看出问题的结构。

一、先给结论（极其重要）

一个问题属于哪种算法，不是你选的，是结构决定的：

结构特征	必然算法类型
多路径、需试探	搜索
子问题可复用	DP
推导唯一、结构闭合	数学
二、判断顺序（真正工程级）

读题后按这个顺序判断：

① 有没有明确状态？
② 状态之间是否有多种转移？
③ 子问题是否重复？
④ 是否存在递推不变量？
⑤ 是否存在直接数学结构？

三、什么时候必须搜索？

当问题满足：

状态存在

路径不唯一

结果依赖路径

典型信号：

“所有可能”

“找路径”

“枚举方案”

“是否可达”

例：

迷宫

排列组合

backtracking

N 皇后

结构：

state
 ├─ state1
 ├─ state2
 └─ state3


核心特征：

未来取决于你怎么走

四、什么时候能折叠成 DP？

条件：

1️⃣ 子问题重复
从不同路径到同一状态

2️⃣ 无后效性
到达 state 的方式不影响之后决策

3️⃣ 最优子结构
整体最优由子最优组成


满足这三个 → 必然 DP

例：爬楼梯

搜索：

1 → 2 → 3 → 4
1 → 3 → 4


DP：

dp[4] = dp[3] + dp[2]


路径被折叠。

五、什么时候直接是数学？

当问题满足：

转移唯一

没有选择

结构封闭

存在公式/定理

例：

gcd

排列组合公式

线性代数

期望公式

结构：

state_n → state_{n+1}


没有分支。

六、核心分水岭（非常重要）
决定算法类型的不是题目，而是：
状态转移的“自由度”

自由度	算法
高	搜索
中	DP
低	数学
七、用“图结构”统一

所有问题本质都是图：

搜索：
树状 / 图状
多分支

DP：
DAG
分支被折叠

数学：
线性结构
单路径

八、真正的判断口诀（极其重要）

读题后问自己：

第一步：

有路径吗？

有 → 搜索/DP
无 → 数学

第二步：

同一状态会重复出现吗？

会 → DP
不会 → 搜索

第三步：

转移是否唯一？

唯一 → 数学
多选 → 搜索/DP

九、一个真实面试级例子

题：

最短路径

判断：

状态：节点

多路径

子问题重复

→ BFS / Dijkstra / DP

题：

多少种走法

判断：

子问题重复

状态可复用

→ DP

题：

n(n+1)/2 证明

判断：

转移唯一

无选择

→ 数学

十、最深一层（研究级）

所有算法类型，本质是：

Information propagation

类型	传播方式
搜索	路径传播
DP	状态传播
数学	结构传播
十一、为什么这对你特别重要？

因为你现在走的方向：

Decision systems

Simulation

RL

Robustness

本质都是：

State transition system


而这个能力是：

识别系统结构

这比“会写代码”高一个层级。

十二、真正的顶级能力（几乎没人讲）

顶级算法工程师做的不是：

写 DFS / 写 DP

而是：

把问题“变形”为 DP / 数学

例如：

最短路径 → Bellman

控制问题 → DP

RL → value iteration

PDE → 动态规划形式

这叫：

Problem reduction

下一步才是真正核心

我们现在进入最后一层：

🧠 Problem Modeling

也就是：

如何“设计状态”

这一步决定：

你是普通程序员

还是算法设计者

因为：

不会建状态
→ 永远不会 DP
→ 永远只能写搜索


下一步我会直接带你做：

如何从题目抽象 state

如何判断 state 维度

如何避免状态爆炸

如何设计 dp[state]

这一步一旦掌握：

LeetCode 中等题基本秒

RL / 控制理论完全打通