# 模型、数据结构不变量与算法不变量（Notes）

## 1. 总体框架：问题 → 模型 → 表示 → 算法

任何计算问题都可以用四层结构理解：

现实问题
↓
数学模型（抽象）
↓
计算表示（数据结构）
↓
算法（求解过程）


说明：

- **模型**：用数学关系描述系统
- **数据结构**：模型在计算机中的表示方式
- **算法**：在该结构上进行操作，得到解

例子：

### 线性代数

问题：几何变换
模型：线性变换
表示：矩阵
算法：矩阵乘法 / 分解


### 决策问题

问题：调度 / 控制
模型：MDP
表示：状态转移图 / 表 / 网络
算法：搜索 / DP / RL


---

## 2. 模型 ≠ 数据结构

关键区分：

| 层级 | 本质 |
|---|---|
| 模型 | 数学关系 |
| 数据结构 | 计算表示 |
| 算法 | 操作过程 |

例：

- 线性变换 → 矩阵（表示）
- 决策系统 → 图（表示）

图/矩阵不是模型本体，只是计算载体。

---

## 3. 模型映射到数据结构后的“结构性限制”

当模型被表示为某种数据结构后：

可操作空间已经被限定


例如：

| 模型 | 数据结构 | 可行运算 |
|---|---|---|
| 关系系统 | 图 | 搜索 / 遍历 |
| 线性变换 | 矩阵 | 分解 / 乘法 |
| 层级关系 | 树 | 递归 / DP |
| 状态转移 | 状态图 | 搜索 / value iteration |

这一步：

> 结构决定可行运算。

---

## 4. 不变量（Invariant）的核心概念

定义：

> 在算法执行过程中始终保持为真的性质。

它是算法正确性的基础。

---

## 5. 两类不变量

### 5.1 结构性不变量（Structural invariants）

由数据结构本身保证。

不需要算法维护。

例：

#### heap

parent ≤ child


#### BST

left < root < right


#### union-find

每个节点指向代表元


#### matrix

行列结构 + 线性运算封闭性


这些由结构定义直接保证。

---

### 5.2 算法性不变量（Algorithmic invariants）

必须在算法过程中通过逻辑维持。

例：

#### 循环不变量

前 i 个元素已排序


#### Dijkstra

visited 集合中的距离是最优


#### greedy

当前选择不会破坏全局最优


#### DP

dp[i] 是子问题最优解


#### 调度

当前选择集合始终可行（不冲突）


---

## 6. 不变量适用范围：Reachable States

不变量成立范围不是：

整个状态空间


而是：

算法执行过程中可到达的状态


形式：

∀ s ∈ ReachableStates :
invariant(s) = true


不是：

∀ s ∈ StateSpace


原因：

- 算法只访问部分状态
- 正确性只需保证这些状态合法

---

## 7. 算法正确性的本质

所有正确性证明都基于：

Initialization
Maintenance
Termination


即：

1. 初始状态满足 invariant
2. 每一步转移保持 invariant
3. 终止时 invariant 推出正确解

适用于：

- loop
- DP
- greedy
- graph
- search

---

## 8. 不变量与算法类型的关系

| 算法类型 | 关键不变量 |
|---|---|
| 循环算法 | loop invariant |
| DP | 最优子结构 invariant |
| greedy | 安全选择 invariant |
| 图搜索 | frontier / distance invariant |
| 数据结构 | 结构 invariant |
| 数值算法 | 收敛 / 正定 invariant |

---

## 9. 更深的统一视角

算法设计本质：

设计状态转移规则
使得 invariant 始终成立


即：

> 控制 reachable states。

剪枝、条件判断、本地更新，本质都是在维持 invariant。

---

## 10. 结构 vs 算法 的职责分工

理想设计：

尽量让结构保证 invariant
减少算法负担


原因：

- 结构 invariant 稳定
- 算法 invariant 容易破坏

例如：

- type system
- immutable data
- algebraic structures

都是把 invariant 上移到结构层。

---

## 11. 统一总结

可以用一条链条概括：

模型
→ 数据结构（内嵌结构不变量）
→ 算法（维持额外不变量）
→ 正确性与最优性


更抽象：

Model
→ Structure
→ Invariants
→ Computation


---

## 12. 最核心结论

1）模型决定可表示结构  
2）结构决定可行运算  
3）不变量决定算法正确性  
4）算法的任务是维持不变量

一句话总结：

> 算法不是“步骤”，  
> 而是“维持不变量的过程”。