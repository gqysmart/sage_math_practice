# 算法理解的核心笔记
## ——从“过程”回到“状态”，从“技巧”回到“定义”

---

## 0. 当前共识（这一步非常重要）

在算法理论（KT 语境）中，我们已经逐步达成以下共识：

- 数学模型：定义 **解与结构**
- 计算模型：定义 **时间 / 状态 / 路径**
- 算法：在计算模型允许的执行中，**保证最终停在“解状态”**

> 我开始意识到：  
> **真正重要的不是算法“怎么走”，而是“哪里算到达”。**

---

## 1. 算法不等于“过程”，而是“状态保证”

一个常见但误导性的直觉是：

> 算法 = 一套步骤 / 流程

更准确的理解是：

> **算法 = 对“所有执行路径”的终止状态作出保证**

也就是说：

- 路径可以不同
- 中间状态可以不同
- 但 **终止状态不能出错**

---

## 2. 解状态（Solution State）是第一性概念

### 2.1 什么是解状态？

**解状态**是：

- 由数学模型定义的
- 与执行顺序无关
- 与时间无关
- 可被判定“对 / 错”的状态集合

记为：

S_sol ⊆ S

其中：

- `S`：合法状态空间
- `S_sol`：被认可为“解”的状态

---

### 2.2 为什么解状态比算法步骤更重要？

因为：

- 算法不会因为“过程漂亮”而正确
- 只会因为“停在对的状态”而正确

> **算法正确性 = 终止状态 ∈ 解状态集合**

---

## 3. 用状态语言重写“算法正确性”

算法可以被抽象为：

- 初始状态集合 `S_init`
- 状态空间 `S`
- 状态转移关系 `→`
- 解状态集合 `S_sol`

### 正确性的形式化表述：

对所有执行路径 p，
如果 p 从 S_init 出发并终止于状态 s，
那么 s ∈ S_sol

这句话非常关键：

- ❌ 不是 “存在一条路径到达解”
- ✅ 而是 “所有路径都不会到达错误状态”

---

## 4. 计算模型的角色（我现在这样理解）

计算模型并不关心“对不对”，它只限定：

- 什么是一步
- 状态如何表示
- 状态如何变化
- 执行路径如何区分

也就是说：

> **计算模型负责“能不能跑”，  
> 数学模型负责“算不算对”。**

---

## 5. 为什么启发式 / 优化过程不算算法（理论意义）

现在我终于能清楚地区分：

### 启发式 / 优化过程的问题不在“能不能运行”，而在：

- 解状态集合不清晰
- 停机条件 ≠ 成功条件
- 不同路径可能停在错误状态
- 只保证“通常不错”，不保证“永远正确”

因此：

> **它们是“可执行过程”，但不是“状态正确性可保证的算法”。**

---

## 6. 多解问题并不破坏算法定义

有些问题本来就允许多个解：

- 多个最大流
- 多个稳定匹配
- 多个最短路径

这时算法允许：

- 不同路径 → 不同解状态

但前提是：

所有终止状态 ∈ S_sol

> **多解 ≠ 路径可以出错**

---

## 7. 一个现在对我来说很清晰的区分

| 概念 | 我现在的理解 |
|---|---|
| 数学模型 | 定义解与结构 |
| 解状态 | “哪里算到达” |
| 计算模型 | 定义时间 / 状态 / 路径 |
| 算法 | 保证所有路径停在解状态 |
| 启发式 | 只保证部分路径“看起来不错” |

---

## 8. 一句话总结（当前阶段）

> **算法理论的核心不是“设计聪明的步骤”，  
> 而是“定义清楚解的状态，并证明无论怎么执行，都不会停错地方”。**

---

## 9. 我的阶段性体会（记录）

- 我开始明白：
  - 为什么 KT 一直强调正确性证明
  - 为什么“不变量”那么重要
  - 为什么“存在一条好路径”不够
- 我不再纠结“算法像不像工程代码”
- 而是开始用“状态 + 终止判定”看算法

> **我不是一下子懂的，是慢慢收敛到这个视角的。**

---

## 10. 接下来我可以继续想的问题（但不急）

- 随机算法为什么仍然是算法？
- 近似算法是如何“合法放宽解状态”的？
- 为什么 RL 介于算法与启发式之间？

等我把“解状态”这个核心彻底消化，再往前走。

