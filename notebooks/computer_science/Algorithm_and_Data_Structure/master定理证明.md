# 主定理（Master Theorem）证明笔记（递归树法）

---

## 0. 定理形式与目标

考虑递归：

T(n) = a·T(n/b) + f(n)

其中：
- a >= 1：每次分裂成 a 个子问题
- b > 1：每个子问题规模缩小到 n/b
- f(n)：每一层“非递归”的额外工作（分割、合并、扫描等）

目标：求 T(n) 的渐进阶（Θ）。

---

## 1. 递归树展开：每一层的“总工作量”

把递归展开成一棵树：

- 第 0 层（根）：1 个问题，规模 n，代价 f(n)
- 第 1 层：a 个问题，每个规模 n/b，总代价 a·f(n/b)
- 第 2 层：a^2 个问题，每个规模 n/b^2，总代价 a^2·f(n/b^2)
- 第 i 层：a^i 个问题，每个规模 n/b^i，总代价：

W_i = a^i · f(n / b^i)

递归会展开到子问题规模降到常数（比如 1）为止。
层数 L 满足：

n / b^L ≈ 1  =>  L = Θ(log_b n)

因此：

T(n) = (各层非递归代价之和) + (叶子层代价)

即：

T(n) = Σ_{i=0}^{L-1} a^i f(n/b^i)  +  叶子项

---

## 2. 叶子项（递归到底部的总代价）

当规模变为 1 时：
- 叶子数量 = a^L
- 若 T(1)=Θ(1)，则叶子总代价 = Θ(a^L)

又因为 L = log_b n：

a^L = a^{log_b n} = n^{log_b a}

所以叶子项是：

Leaf = Θ(n^{log_b a})

这就是主定理里反复出现的关键量：

n^{log_b a}

它代表“递归展开的规模效应”。

---

## 3. 关键思想：比较每层代价与叶子规模

主定理的核心就是比较：

f(n) 与 n^{log_b a}

更精确地说：比较每层 W_i 的衰减/增长趋势。

为了看清趋势，把 W_i 写成“相对根的缩放”：
设 k = log_b a，则 a = b^k。

那么：

W_i = a^i f(n/b^i) = (b^k)^i f(n/b^i) = b^{ki} f(n/b^i)

接下来进入三种典型情形。

---

## 4. Case 1：f(n) 比 n^{log_b a} 小（叶子主导）

条件：
f(n) = O(n^{k - ε})  (ε > 0)

直觉：
- 每层“额外工作”增长得不够快
- 递归分裂产生的大量叶子主导总成本

证明（递归树求和）：

第 i 层代价：
W_i = a^i f(n/b^i)
    <= a^i · C (n/b^i)^{k-ε}
    = C · a^i · n^{k-ε} / b^{i(k-ε)}
    = C · n^{k-ε} · (a / b^{k-ε})^i

但 a = b^k，所以：

a / b^{k-ε} = b^k / b^{k-ε} = b^{ε} > 1

这意味着：随着 i 增加，W_i 反而变大，最大层出现在最底层附近。
因此总和由最后几层（尤其叶子层）主导。

严格结论：
T(n) = Θ(n^k) = Θ(n^{log_b a})

---

## 5. Case 2：f(n) 与 n^{log_b a} 同阶（每层均衡）

条件：
f(n) = Θ(n^k)

直觉：
- 每一层的总工作量都差不多
- 有 Θ(log n) 层
- 总成本 = “每层成本 × 层数”

证明：

W_i = a^i f(n/b^i)
    = a^i · Θ((n/b^i)^k)
    = Θ(a^i · n^k / b^{ik})
    = Θ(n^k · (a / b^k)^i)

但 a = b^k，所以：

(a / b^k)^i = 1^i = 1

因此每一层：

W_i = Θ(n^k)

层数 L = Θ(log n)，所以：

Σ W_i = Θ(n^k log n)

叶子项也是 Θ(n^k)，但被 n^k log n 压过：

T(n) = Θ(n^k log n)

即：

T(n) = Θ(n^{log_b a} log n)

---

## 6. Case 3：f(n) 比 n^{log_b a} 大（根主导）

条件（增长更快）：
f(n) = Ω(n^{k+ε})  (ε > 0)

但还需要一个“正则条件”（regularity condition）：
a f(n/b) <= c f(n)  对某个常数 c < 1 且足够大 n 成立

这个条件的作用：
- 保证“下一层的总代价”比“上一层”按固定比例下降
- 避免 f(n) 形状怪异导致下层又反弹

证明（用正则条件做几何级数）：

第 0 层代价：W_0 = f(n)

第 1 层代价：W_1 = a f(n/b) <= c f(n)

同理可推出：
W_2 = a^2 f(n/b^2) <= c^2 f(n)
...
W_i <= c^i f(n)

于是各层和是几何级数：

Σ_{i=0}^{L-1} W_i <= f(n) Σ_{i=0}^{∞} c^i = f(n) / (1-c) = Θ(f(n))

叶子项 n^k 相比 f(n)=Ω(n^{k+ε}) 低一阶，可忽略。

结论：

T(n) = Θ(f(n))

---

## 7. 结论：主定理三种情形（汇总）

令 k = log_b a。

1) 若 f(n) = O(n^{k-ε})：
   T(n) = Θ(n^k)

2) 若 f(n) = Θ(n^k)：
   T(n) = Θ(n^k log n)

3) 若 f(n) = Ω(n^{k+ε}) 且满足正则条件 a f(n/b) <= c f(n)：
   T(n) = Θ(f(n))

---

## 8. 主定理“到底证明了什么”

主定理的证明本质是：

- 用递归树把 T(n) 写成“各层总工作量之和”
- 各层工作量的变化是由 a 与 b（分裂倍率 vs 缩小倍率）决定的
- n^{log_b a} 是“递归自身”产生的规模基准
- 比较 f(n) 和这个基准，就知道哪一部分主导总时间

一句话：
主定理 = “递归树层级求和 + 主导项判定”。

